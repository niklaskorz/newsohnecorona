{"version":3,"file":"bundle.js","sources":["../node_modules/svelte/internal/index.mjs","../node_modules/xml-js/lib/xml2js.js","../node_modules/sax/lib/sax.js","../node_modules/xml-js/lib/array-helper.js","../node_modules/xml-js/lib/options-helper.js","../node_modules/xml-js/lib/js2xml.js","../node_modules/xml-js/lib/index.js","../App.svelte","../index.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true && boolean_attributes.has(name) ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.45.0' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","var sax = require('sax');\r\nvar expat /*= require('node-expat');*/ = { on: function () { }, parse: function () { } };\r\nvar helper = require('./options-helper');\r\nvar isArray = require('./array-helper').isArray;\r\n\r\nvar options;\r\nvar pureJsParser = true;\r\nvar currentElement;\r\n\r\nfunction validateOptions(userOptions) {\r\n  options = helper.copyOptions(userOptions);\r\n  helper.ensureFlagExists('ignoreDeclaration', options);\r\n  helper.ensureFlagExists('ignoreInstruction', options);\r\n  helper.ensureFlagExists('ignoreAttributes', options);\r\n  helper.ensureFlagExists('ignoreText', options);\r\n  helper.ensureFlagExists('ignoreComment', options);\r\n  helper.ensureFlagExists('ignoreCdata', options);\r\n  helper.ensureFlagExists('ignoreDoctype', options);\r\n  helper.ensureFlagExists('compact', options);\r\n  helper.ensureFlagExists('alwaysChildren', options);\r\n  helper.ensureFlagExists('addParent', options);\r\n  helper.ensureFlagExists('trim', options);\r\n  helper.ensureFlagExists('nativeType', options);\r\n  helper.ensureFlagExists('nativeTypeAttributes', options);\r\n  helper.ensureFlagExists('sanitize', options);\r\n  helper.ensureFlagExists('instructionHasAttributes', options);\r\n  helper.ensureFlagExists('captureSpacesBetweenElements', options);\r\n  helper.ensureAlwaysArrayExists(options);\r\n  helper.ensureKeyExists('declaration', options);\r\n  helper.ensureKeyExists('instruction', options);\r\n  helper.ensureKeyExists('attributes', options);\r\n  helper.ensureKeyExists('text', options);\r\n  helper.ensureKeyExists('comment', options);\r\n  helper.ensureKeyExists('cdata', options);\r\n  helper.ensureKeyExists('doctype', options);\r\n  helper.ensureKeyExists('type', options);\r\n  helper.ensureKeyExists('name', options);\r\n  helper.ensureKeyExists('elements', options);\r\n  helper.ensureKeyExists('parent', options);\r\n  helper.checkFnExists('doctype', options);\r\n  helper.checkFnExists('instruction', options);\r\n  helper.checkFnExists('cdata', options);\r\n  helper.checkFnExists('comment', options);\r\n  helper.checkFnExists('text', options);\r\n  helper.checkFnExists('instructionName', options);\r\n  helper.checkFnExists('elementName', options);\r\n  helper.checkFnExists('attributeName', options);\r\n  helper.checkFnExists('attributeValue', options);\r\n  helper.checkFnExists('attributes', options);\r\n  return options;\r\n}\r\n\r\nfunction nativeType(value) {\r\n  var nValue = Number(value);\r\n  if (!isNaN(nValue)) {\r\n    return nValue;\r\n  }\r\n  var bValue = value.toLowerCase();\r\n  if (bValue === 'true') {\r\n    return true;\r\n  } else if (bValue === 'false') {\r\n    return false;\r\n  }\r\n  return value;\r\n}\r\n\r\nfunction addField(type, value) {\r\n  var key;\r\n  if (options.compact) {\r\n    if (\r\n      !currentElement[options[type + 'Key']] &&\r\n      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)\r\n    ) {\r\n      currentElement[options[type + 'Key']] = [];\r\n    }\r\n    if (currentElement[options[type + 'Key']] && !isArray(currentElement[options[type + 'Key']])) {\r\n      currentElement[options[type + 'Key']] = [currentElement[options[type + 'Key']]];\r\n    }\r\n    if (type + 'Fn' in options && typeof value === 'string') {\r\n      value = options[type + 'Fn'](value, currentElement);\r\n    }\r\n    if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {\r\n      for (key in value) {\r\n        if (value.hasOwnProperty(key)) {\r\n          if ('instructionFn' in options) {\r\n            value[key] = options.instructionFn(value[key], key, currentElement);\r\n          } else {\r\n            var temp = value[key];\r\n            delete value[key];\r\n            value[options.instructionNameFn(key, temp, currentElement)] = temp;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (isArray(currentElement[options[type + 'Key']])) {\r\n      currentElement[options[type + 'Key']].push(value);\r\n    } else {\r\n      currentElement[options[type + 'Key']] = value;\r\n    }\r\n  } else {\r\n    if (!currentElement[options.elementsKey]) {\r\n      currentElement[options.elementsKey] = [];\r\n    }\r\n    var element = {};\r\n    element[options.typeKey] = type;\r\n    if (type === 'instruction') {\r\n      for (key in value) {\r\n        if (value.hasOwnProperty(key)) {\r\n          break;\r\n        }\r\n      }\r\n      element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;\r\n      if (options.instructionHasAttributes) {\r\n        element[options.attributesKey] = value[key][options.attributesKey];\r\n        if ('instructionFn' in options) {\r\n          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);\r\n        }\r\n      } else {\r\n        if ('instructionFn' in options) {\r\n          value[key] = options.instructionFn(value[key], key, currentElement);\r\n        }\r\n        element[options.instructionKey] = value[key];\r\n      }\r\n    } else {\r\n      if (type + 'Fn' in options) {\r\n        value = options[type + 'Fn'](value, currentElement);\r\n      }\r\n      element[options[type + 'Key']] = value;\r\n    }\r\n    if (options.addParent) {\r\n      element[options.parentKey] = currentElement;\r\n    }\r\n    currentElement[options.elementsKey].push(element);\r\n  }\r\n}\r\n\r\nfunction manipulateAttributes(attributes) {\r\n  if ('attributesFn' in options && attributes) {\r\n    attributes = options.attributesFn(attributes, currentElement);\r\n  }\r\n  if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {\r\n    var key;\r\n    for (key in attributes) {\r\n      if (attributes.hasOwnProperty(key)) {\r\n        if (options.trim) attributes[key] = attributes[key].trim();\r\n        if (options.nativeTypeAttributes) {\r\n          attributes[key] = nativeType(attributes[key]);\r\n        }\r\n        if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);\r\n        if ('attributeNameFn' in options) {\r\n          var temp = attributes[key];\r\n          delete attributes[key];\r\n          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return attributes;\r\n}\r\n\r\nfunction onInstruction(instruction) {\r\n  var attributes = {};\r\n  if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {\r\n    var attrsRegExp = /([\\w:-]+)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\w+))\\s*/g;\r\n    var match;\r\n    while ((match = attrsRegExp.exec(instruction.body)) !== null) {\r\n      attributes[match[1]] = match[2] || match[3] || match[4];\r\n    }\r\n    attributes = manipulateAttributes(attributes);\r\n  }\r\n  if (instruction.name.toLowerCase() === 'xml') {\r\n    if (options.ignoreDeclaration) {\r\n      return;\r\n    }\r\n    currentElement[options.declarationKey] = {};\r\n    if (Object.keys(attributes).length) {\r\n      currentElement[options.declarationKey][options.attributesKey] = attributes;\r\n    }\r\n    if (options.addParent) {\r\n      currentElement[options.declarationKey][options.parentKey] = currentElement;\r\n    }\r\n  } else {\r\n    if (options.ignoreInstruction) {\r\n      return;\r\n    }\r\n    if (options.trim) {\r\n      instruction.body = instruction.body.trim();\r\n    }\r\n    var value = {};\r\n    if (options.instructionHasAttributes && Object.keys(attributes).length) {\r\n      value[instruction.name] = {};\r\n      value[instruction.name][options.attributesKey] = attributes;\r\n    } else {\r\n      value[instruction.name] = instruction.body;\r\n    }\r\n    addField('instruction', value);\r\n  }\r\n}\r\n\r\nfunction onStartElement(name, attributes) {\r\n  var element;\r\n  if (typeof name === 'object') {\r\n    attributes = name.attributes;\r\n    name = name.name;\r\n  }\r\n  attributes = manipulateAttributes(attributes);\r\n  if ('elementNameFn' in options) {\r\n    name = options.elementNameFn(name, currentElement);\r\n  }\r\n  if (options.compact) {\r\n    element = {};\r\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\r\n      element[options.attributesKey] = {};\r\n      var key;\r\n      for (key in attributes) {\r\n        if (attributes.hasOwnProperty(key)) {\r\n          element[options.attributesKey][key] = attributes[key];\r\n        }\r\n      }\r\n    }\r\n    if (\r\n      !(name in currentElement) &&\r\n      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)\r\n    ) {\r\n      currentElement[name] = [];\r\n    }\r\n    if (currentElement[name] && !isArray(currentElement[name])) {\r\n      currentElement[name] = [currentElement[name]];\r\n    }\r\n    if (isArray(currentElement[name])) {\r\n      currentElement[name].push(element);\r\n    } else {\r\n      currentElement[name] = element;\r\n    }\r\n  } else {\r\n    if (!currentElement[options.elementsKey]) {\r\n      currentElement[options.elementsKey] = [];\r\n    }\r\n    element = {};\r\n    element[options.typeKey] = 'element';\r\n    element[options.nameKey] = name;\r\n    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\r\n      element[options.attributesKey] = attributes;\r\n    }\r\n    if (options.alwaysChildren) {\r\n      element[options.elementsKey] = [];\r\n    }\r\n    currentElement[options.elementsKey].push(element);\r\n  }\r\n  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent\r\n  currentElement = element;\r\n}\r\n\r\nfunction onText(text) {\r\n  if (options.ignoreText) {\r\n    return;\r\n  }\r\n  if (!text.trim() && !options.captureSpacesBetweenElements) {\r\n    return;\r\n  }\r\n  if (options.trim) {\r\n    text = text.trim();\r\n  }\r\n  if (options.nativeType) {\r\n    text = nativeType(text);\r\n  }\r\n  if (options.sanitize) {\r\n    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\r\n  }\r\n  addField('text', text);\r\n}\r\n\r\nfunction onComment(comment) {\r\n  if (options.ignoreComment) {\r\n    return;\r\n  }\r\n  if (options.trim) {\r\n    comment = comment.trim();\r\n  }\r\n  addField('comment', comment);\r\n}\r\n\r\nfunction onEndElement(name) {\r\n  var parentElement = currentElement[options.parentKey];\r\n  if (!options.addParent) {\r\n    delete currentElement[options.parentKey];\r\n  }\r\n  currentElement = parentElement;\r\n}\r\n\r\nfunction onCdata(cdata) {\r\n  if (options.ignoreCdata) {\r\n    return;\r\n  }\r\n  if (options.trim) {\r\n    cdata = cdata.trim();\r\n  }\r\n  addField('cdata', cdata);\r\n}\r\n\r\nfunction onDoctype(doctype) {\r\n  if (options.ignoreDoctype) {\r\n    return;\r\n  }\r\n  doctype = doctype.replace(/^ /, '');\r\n  if (options.trim) {\r\n    doctype = doctype.trim();\r\n  }\r\n  addField('doctype', doctype);\r\n}\r\n\r\nfunction onError(error) {\r\n  error.note = error; //console.error(error);\r\n}\r\n\r\nmodule.exports = function (xml, userOptions) {\r\n\r\n  var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser('UTF-8');\r\n  var result = {};\r\n  currentElement = result;\r\n\r\n  options = validateOptions(userOptions);\r\n\r\n  if (pureJsParser) {\r\n    parser.opt = {strictEntities: true};\r\n    parser.onopentag = onStartElement;\r\n    parser.ontext = onText;\r\n    parser.oncomment = onComment;\r\n    parser.onclosetag = onEndElement;\r\n    parser.onerror = onError;\r\n    parser.oncdata = onCdata;\r\n    parser.ondoctype = onDoctype;\r\n    parser.onprocessinginstruction = onInstruction;\r\n  } else {\r\n    parser.on('startElement', onStartElement);\r\n    parser.on('text', onText);\r\n    parser.on('comment', onComment);\r\n    parser.on('endElement', onEndElement);\r\n    parser.on('error', onError);\r\n    //parser.on('startCdata', onStartCdata);\r\n    //parser.on('endCdata', onEndCdata);\r\n    //parser.on('entityDecl', onEntityDecl);\r\n  }\r\n\r\n  if (pureJsParser) {\r\n    parser.write(xml).close();\r\n  } else {\r\n    if (!parser.parse(xml)) {\r\n      throw new Error('XML parsing error: ' + parser.getError());\r\n    }\r\n  }\r\n\r\n  if (result[options.elementsKey]) {\r\n    var temp = result[options.elementsKey];\r\n    delete result[options.elementsKey];\r\n    result[options.elementsKey] = temp;\r\n    delete result.text;\r\n  }\r\n\r\n  return result;\r\n\r\n};\r\n",";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n","module.exports = {\r\n\r\n  isArray: function(value) {\r\n    if (Array.isArray) {\r\n      return Array.isArray(value);\r\n    }\r\n    // fallback for older browsers like  IE 8\r\n    return Object.prototype.toString.call( value ) === '[object Array]';\r\n  }\r\n\r\n};\r\n","var isArray = require('./array-helper').isArray;\r\n\r\nmodule.exports = {\r\n\r\n  copyOptions: function (options) {\r\n    var key, copy = {};\r\n    for (key in options) {\r\n      if (options.hasOwnProperty(key)) {\r\n        copy[key] = options[key];\r\n      }\r\n    }\r\n    return copy;\r\n  },\r\n\r\n  ensureFlagExists: function (item, options) {\r\n    if (!(item in options) || typeof options[item] !== 'boolean') {\r\n      options[item] = false;\r\n    }\r\n  },\r\n\r\n  ensureSpacesExists: function (options) {\r\n    if (!('spaces' in options) || (typeof options.spaces !== 'number' && typeof options.spaces !== 'string')) {\r\n      options.spaces = 0;\r\n    }\r\n  },\r\n\r\n  ensureAlwaysArrayExists: function (options) {\r\n    if (!('alwaysArray' in options) || (typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray))) {\r\n      options.alwaysArray = false;\r\n    }\r\n  },\r\n\r\n  ensureKeyExists: function (key, options) {\r\n    if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {\r\n      options[key + 'Key'] = options.compact ? '_' + key : key;\r\n    }\r\n  },\r\n\r\n  checkFnExists: function (key, options) {\r\n    return key + 'Fn' in options;\r\n  }\r\n\r\n};\r\n","var helper = require('./options-helper');\nvar isArray = require('./array-helper').isArray;\n\nvar currentElement, currentElementName;\n\nfunction validateOptions(userOptions) {\n  var options = helper.copyOptions(userOptions);\n  helper.ensureFlagExists('ignoreDeclaration', options);\n  helper.ensureFlagExists('ignoreInstruction', options);\n  helper.ensureFlagExists('ignoreAttributes', options);\n  helper.ensureFlagExists('ignoreText', options);\n  helper.ensureFlagExists('ignoreComment', options);\n  helper.ensureFlagExists('ignoreCdata', options);\n  helper.ensureFlagExists('ignoreDoctype', options);\n  helper.ensureFlagExists('compact', options);\n  helper.ensureFlagExists('indentText', options);\n  helper.ensureFlagExists('indentCdata', options);\n  helper.ensureFlagExists('indentAttributes', options);\n  helper.ensureFlagExists('indentInstruction', options);\n  helper.ensureFlagExists('fullTagEmptyElement', options);\n  helper.ensureFlagExists('noQuotesForNativeAttributes', options);\n  helper.ensureSpacesExists(options);\n  if (typeof options.spaces === 'number') {\n    options.spaces = Array(options.spaces + 1).join(' ');\n  }\n  helper.ensureKeyExists('declaration', options);\n  helper.ensureKeyExists('instruction', options);\n  helper.ensureKeyExists('attributes', options);\n  helper.ensureKeyExists('text', options);\n  helper.ensureKeyExists('comment', options);\n  helper.ensureKeyExists('cdata', options);\n  helper.ensureKeyExists('doctype', options);\n  helper.ensureKeyExists('type', options);\n  helper.ensureKeyExists('name', options);\n  helper.ensureKeyExists('elements', options);\n  helper.checkFnExists('doctype', options);\n  helper.checkFnExists('instruction', options);\n  helper.checkFnExists('cdata', options);\n  helper.checkFnExists('comment', options);\n  helper.checkFnExists('text', options);\n  helper.checkFnExists('instructionName', options);\n  helper.checkFnExists('elementName', options);\n  helper.checkFnExists('attributeName', options);\n  helper.checkFnExists('attributeValue', options);\n  helper.checkFnExists('attributes', options);\n  helper.checkFnExists('fullTagEmptyElement', options);\n  return options;\n}\n\nfunction writeIndentation(options, depth, firstLine) {\n  return (!firstLine && options.spaces ? '\\n' : '') + Array(depth + 1).join(options.spaces);\n}\n\nfunction writeAttributes(attributes, options, depth) {\n  if (options.ignoreAttributes) {\n    return '';\n  }\n  if ('attributesFn' in options) {\n    attributes = options.attributesFn(attributes, currentElementName, currentElement);\n  }\n  var key, attr, attrName, quote, result = [];\n  for (key in attributes) {\n    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {\n      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '\"';\n      attr = '' + attributes[key]; // ensure number and boolean are converted to String\n      attr = attr.replace(/\"/g, '&quot;');\n      attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;\n      result.push((options.spaces && options.indentAttributes? writeIndentation(options, depth+1, false) : ' '));\n      result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);\n    }\n  }\n  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {\n    result.push(writeIndentation(options, depth, false));\n  }\n  return result.join('');\n}\n\nfunction writeDeclaration(declaration, options, depth) {\n  currentElement = declaration;\n  currentElementName = 'xml';\n  return options.ignoreDeclaration ? '' :  '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';\n}\n\nfunction writeInstruction(instruction, options, depth) {\n  if (options.ignoreInstruction) {\n    return '';\n  }\n  var key;\n  for (key in instruction) {\n    if (instruction.hasOwnProperty(key)) {\n      break;\n    }\n  }\n  var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;\n  if (typeof instruction[key] === 'object') {\n    currentElement = instruction;\n    currentElementName = instructionName;\n    return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';\n  } else {\n    var instructionValue = instruction[key] ? instruction[key] : '';\n    if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);\n    return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';\n  }\n}\n\nfunction writeComment(comment, options) {\n  return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';\n}\n\nfunction writeCdata(cdata, options) {\n  return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';\n}\n\nfunction writeDoctype(doctype, options) {\n  return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';\n}\n\nfunction writeText(text, options) {\n  if (options.ignoreText) return '';\n  text = '' + text; // ensure Number and Boolean are converted to String\n  text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization\n  text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;\n}\n\nfunction hasContent(element, options) {\n  var i;\n  if (element.elements && element.elements.length) {\n    for (i = 0; i < element.elements.length; ++i) {\n      switch (element.elements[i][options.typeKey]) {\n      case 'text':\n        if (options.indentText) {\n          return true;\n        }\n        break; // skip to next key\n      case 'cdata':\n        if (options.indentCdata) {\n          return true;\n        }\n        break; // skip to next key\n      case 'instruction':\n        if (options.indentInstruction) {\n          return true;\n        }\n        break; // skip to next key\n      case 'doctype':\n      case 'comment':\n      case 'element':\n        return true;\n      default:\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction writeElement(element, options, depth) {\n  currentElement = element;\n  currentElementName = element.name;\n  var xml = [], elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;\n  xml.push('<' + elementName);\n  if (element[options.attributesKey]) {\n    xml.push(writeAttributes(element[options.attributesKey], options, depth));\n  }\n  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';\n  if (!withClosingTag) {\n    if ('fullTagEmptyElementFn' in options) {\n      withClosingTag = options.fullTagEmptyElementFn(element.name, element);\n    } else {\n      withClosingTag = options.fullTagEmptyElement;\n    }\n  }\n  if (withClosingTag) {\n    xml.push('>');\n    if (element[options.elementsKey] && element[options.elementsKey].length) {\n      xml.push(writeElements(element[options.elementsKey], options, depth + 1));\n      currentElement = element;\n      currentElementName = element.name;\n    }\n    xml.push(options.spaces && hasContent(element, options) ? '\\n' + Array(depth + 1).join(options.spaces) : '');\n    xml.push('</' + elementName + '>');\n  } else {\n    xml.push('/>');\n  }\n  return xml.join('');\n}\n\nfunction writeElements(elements, options, depth, firstLine) {\n  return elements.reduce(function (xml, element) {\n    var indent = writeIndentation(options, depth, firstLine && !xml);\n    switch (element.type) {\n    case 'element': return xml + indent + writeElement(element, options, depth);\n    case 'comment': return xml + indent + writeComment(element[options.commentKey], options);\n    case 'doctype': return xml + indent + writeDoctype(element[options.doctypeKey], options);\n    case 'cdata': return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);\n    case 'text': return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);\n    case 'instruction':\n      var instruction = {};\n      instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];\n      return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);\n    }\n  }, '');\n}\n\nfunction hasContentCompact(element, options, anyContent) {\n  var key;\n  for (key in element) {\n    if (element.hasOwnProperty(key)) {\n      switch (key) {\n      case options.parentKey:\n      case options.attributesKey:\n        break; // skip to next key\n      case options.textKey:\n        if (options.indentText || anyContent) {\n          return true;\n        }\n        break; // skip to next key\n      case options.cdataKey:\n        if (options.indentCdata || anyContent) {\n          return true;\n        }\n        break; // skip to next key\n      case options.instructionKey:\n        if (options.indentInstruction || anyContent) {\n          return true;\n        }\n        break; // skip to next key\n      case options.doctypeKey:\n      case options.commentKey:\n        return true;\n      default:\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction writeElementCompact(element, name, options, depth, indent) {\n  currentElement = element;\n  currentElementName = name;\n  var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;\n  if (typeof element === 'undefined' || element === null || element === '') {\n    return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';\n  }\n  var xml = [];\n  if (name) {\n    xml.push('<' + elementName);\n    if (typeof element !== 'object') {\n      xml.push('>' + writeText(element,options) + '</' + elementName + '>');\n      return xml.join('');\n    }\n    if (element[options.attributesKey]) {\n      xml.push(writeAttributes(element[options.attributesKey], options, depth));\n    }\n    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';\n    if (!withClosingTag) {\n      if ('fullTagEmptyElementFn' in options) {\n        withClosingTag = options.fullTagEmptyElementFn(name, element);\n      } else {\n        withClosingTag = options.fullTagEmptyElement;\n      }\n    }\n    if (withClosingTag) {\n      xml.push('>');\n    } else {\n      xml.push('/>');\n      return xml.join('');\n    }\n  }\n  xml.push(writeElementsCompact(element, options, depth + 1, false));\n  currentElement = element;\n  currentElementName = name;\n  if (name) {\n    xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');\n  }\n  return xml.join('');\n}\n\nfunction writeElementsCompact(element, options, depth, firstLine) {\n  var i, key, nodes, xml = [];\n  for (key in element) {\n    if (element.hasOwnProperty(key)) {\n      nodes = isArray(element[key]) ? element[key] : [element[key]];\n      for (i = 0; i < nodes.length; ++i) {\n        switch (key) {\n        case options.declarationKey: xml.push(writeDeclaration(nodes[i], options, depth)); break;\n        case options.instructionKey: xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth)); break;\n        case options.attributesKey: case options.parentKey: break; // skip\n        case options.textKey: xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options)); break;\n        case options.cdataKey: xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options)); break;\n        case options.doctypeKey: xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options)); break;\n        case options.commentKey: xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options)); break;\n        default: xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));\n        }\n        firstLine = firstLine && !xml.length;\n      }\n    }\n  }\n  return xml.join('');\n}\n\nmodule.exports = function (js, options) {\n  options = validateOptions(options);\n  var xml = [];\n  currentElement = js;\n  currentElementName = '_root_';\n  if (options.compact) {\n    xml.push(writeElementsCompact(js, options, 0, true));\n  } else {\n    if (js[options.declarationKey]) {\n      xml.push(writeDeclaration(js[options.declarationKey], options, 0));\n    }\n    if (js[options.elementsKey] && js[options.elementsKey].length) {\n      xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));\n    }\n  }\n  return xml.join('');\n};\n","/*jslint node:true */\r\n\r\nvar xml2js = require('./xml2js');\r\nvar xml2json = require('./xml2json');\r\nvar js2xml = require('./js2xml');\r\nvar json2xml = require('./json2xml');\r\n\r\nmodule.exports = {\r\n  xml2js: xml2js,\r\n  xml2json: xml2json,\r\n  js2xml: js2xml,\r\n  json2xml: json2xml\r\n};\r\n","<script>\n  import { xml2js } from \"xml-js\";\n\n  const keywords = [\n    \"corona\",\n    \"omikron\",\n    \"inzidenz\",\n    \"luca-app\",\n    \"impfung\",\n    \"impfpflicht\"\n  ];\n\n  let selectedSource = \"Tagesschau\";\n  let articles = [];\n\n  const feeds = {\n    Tagesschau: \"https://www.tagesschau.de/xml/rss2/\",\n    \"SWR Aktuell\": \"https://www.swr.de/~rss/swraktuell/swraktuell-100.xml\",\n    \"SWR Aktuell BW\": \"https://www.swr.de/~rss/swraktuell/swraktuell-bw-100.xml\",\n    \"SWR Aktuell RP\": \"https://www.swr.de/~rss/swraktuell/swraktuell-rp-100.xml\"\n  };\n\n  async function getFeed(name) {\n    selectedSource = name;\n    const resp = await fetch(feeds[name]);\n    const text = await resp.text();\n    const data = xml2js(text, { compact: true });\n    articles = data.rss.channel.item\n      .filter(item =>\n        keywords.every(\n          keyword =>\n            !item.title._text.toLowerCase().includes(keyword) &&\n            !item.description._text.toLowerCase().includes(keyword)\n        )\n      )\n      .map(item => ({\n        title: item.title._text,\n        description: item.description._text,\n        link: item.link._text,\n        date: new Date(item.pubDate._text)\n      }))\n      .sort((a, b) => b.date.getTime() - a.date.getTime());\n  }\n  getFeed(selectedSource);\n</script>\n\n<style>\n  :global(body) {\n    background: #fafafa;\n    font-family: Helvetica;\n  }\n\n  main {\n    max-width: 600px;\n    margin-left: auto;\n    margin-right: auto;\n  }\n\n  nav {\n    background: #333;\n  }\n\n  nav > ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n  }\n\n  nav > ul > li {\n    display: inline-block;\n  }\n\n  nav > ul > li.active,\n  nav > ul > li:hover {\n    background: #555;\n  }\n\n  nav > ul > li > a {\n    display: inline-block;\n    padding: 10px;\n    color: #fff;\n    text-decoration: none;\n  }\n\n  article {\n    margin-top: 40px;\n  }\n\n  h2 {\n    margin-bottom: 5px;\n  }\n\n  h2 > a {\n    text-decoration: none;\n    color: #111;\n  }\n\n  h2 > a:hover {\n    text-decoration: underline;\n  }\n\n  h3 {\n    margin-top: 0;\n    color: #444;\n  }\n</style>\n\n<main>\n  <h1>{selectedSource} ohne Corona</h1>\n  <nav>\n    <ul>\n      {#each Object.keys(feeds) as source}\n      <li class={source === selectedSource ? \"active\" : \"\"}><a href=\"#\" on:click={() => getFeed(source)}>{source}</a></li>\n      {/each}\n    </ul>\n  </nav>\n\t{#each articles as article}\n  <article>\n    <h2><a href={article.link} target=\"_blank\">{article.title}</a></h2>\n    <h3>{article.date.toLocaleString()}</h3>\n    <p>{article.description}</p>\n  </article>\n  {/each}\n  <hr>\n  <p>Gefilterte Keywords: {keywords.join(\", \")}</p>\n</main>\n","import App from \"./App.svelte\";\n\nconst app = new App({\n  target: document.body\n});\n\nexport default app;\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","null_to_empty","value","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","attr","attribute","removeAttribute","getAttribute","setAttribute","set_data","wholeText","current_component","set_current_component","component","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","push","seen_callbacks","Set","flushidx","flush","saved_component","update","$$","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","make_dirty","then","fill","init","options","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_mount","on_destroy","on_disconnect","context","Map","callbacks","skip_bound","root","ready","ret","rest","hydrate","nodes","Array","from","childNodes","l","c","intro","block","delete","local","customElement","m","new_on_destroy","map","filter","mount_component","SvelteComponent","[object Object]","destroy_component","this","$destroy","type","index","indexOf","splice","$$props","obj","$$set","keys","currentElement","sax","parser","strict","opt","SAXParser","SAXStream","createStream","MAX_BUFFER_LENGTH","Stream","buffers","clearBuffers","q","bufferCheckPosition","lowercase","lowercasetags","looseCase","tags","closed","closedRoot","sawRoot","tag","error","noscript","state","S","BEGIN","strictEntities","ENTITIES","XML_ENTITIES","attribList","xmlns","ns","rootNS","trackPosition","position","line","column","emit","EVENTS","o","F","prototype","hasOwnProperty","end","write","chunk","toString","charAt","BEGIN_WHITESPACE","beginWhiteSpace","TEXT","starti","textNode","substring","isWhitespace","strictFail","TEXT_ENTITY","OPEN_WAKA","startTagPosition","SCRIPT","SCRIPT_ENDING","script","CLOSE_TAG","SGML_DECL","sgmlDecl","isMatch","nameStart","OPEN_TAG","tagName","PROC_INST","procInstName","procInstBody","pad","join","toUpperCase","CDATA","emitNode","cdata","COMMENT","comment","DOCTYPE","doctype","isQuote","SGML_DECL_QUOTED","DOCTYPE_DTD","DOCTYPE_QUOTED","DOCTYPE_DTD_QUOTED","COMMENT_ENDING","COMMENT_ENDED","textopts","CDATA_ENDING","CDATA_ENDING_2","PROC_INST_ENDING","PROC_INST_BODY","body","nameBody","newTag","openTag","OPEN_TAG_SLASH","ATTRIB","closeTag","attribName","attribValue","ATTRIB_NAME","ATTRIB_VALUE","attrib","ATTRIB_NAME_SAW_WHITE","attributes","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_CLOSED","isAttribEnd","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG_SAW_WHITE","notMatch","returnState","buffer","parseEntity","entity","entityBody","entityStart","Error","maxAllowed","Math","max","maxActual","len","closeText","checkBufferLength","resume","close","require$$0","ex","streamWraps","ev","apply","_parser","writable","readable","me","onend","onerror","er","_decoder","defineProperty","get","set","h","removeAllListeners","on","enumerable","configurable","constructor","Buffer","isBuffer","SD","require$$1","StringDecoder","handler","args","arguments","call","XML_NAMESPACE","XMLNS_NAMESPACE","xml","regex","test","stringFromCharCode","floor","fromCodePoint","s","STATE","COMMENT_STARTING","amp","gt","lt","quot","apos","AElig","Aacute","Acirc","Agrave","Aring","Atilde","Auml","Ccedil","ETH","Eacute","Ecirc","Egrave","Euml","Iacute","Icirc","Igrave","Iuml","Ntilde","Oacute","Ocirc","Ograve","Oslash","Otilde","Ouml","THORN","Uacute","Ucirc","Ugrave","Uuml","Yacute","aacute","acirc","aelig","agrave","aring","atilde","auml","ccedil","eacute","ecirc","egrave","eth","euml","iacute","icirc","igrave","iuml","ntilde","oacute","ocirc","ograve","oslash","otilde","ouml","szlig","thorn","uacute","ucirc","ugrave","uuml","yacute","yuml","copy","reg","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","not","shy","macr","deg","plusmn","sup1","sup2","sup3","acute","micro","para","middot","cedil","ordm","raquo","frac14","frac12","frac34","iquest","times","divide","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","key","e","String","fromCharCode","event","nodeType","trim","normalize","replace","message","parent","qname","qualName","split","prefix","qn","selfClosing","uri","JSON","stringify","nv","isSelfClosing","toLowerCase","t","closeTo","x","n","num","entityLC","numStr","slice","parseInt","isNaN","result","highSurrogate","lowSurrogate","codeUnits","codePoint","Number","isFinite","RangeError","exports","isArray","copyOptions","ensureFlagExists","item","ensureSpacesExists","spaces","ensureAlwaysArrayExists","alwaysArray","ensureKeyExists","compact","checkFnExists","nativeType","nValue","bValue","addField","instructionFn","temp","instructionNameFn","elementsKey","typeKey","nameKey","instructionHasAttributes","attributesKey","instructionKey","addParent","parentKey","manipulateAttributes","attributesFn","nativeTypeAttributes","attributeValueFn","attributeNameFn","onInstruction","instruction","match","attrsRegExp","exec","ignoreDeclaration","declarationKey","ignoreInstruction","onStartElement","elementNameFn","ignoreAttributes","alwaysChildren","onText","ignoreText","captureSpacesBetweenElements","sanitize","onComment","ignoreComment","onEndElement","parentElement","onCdata","ignoreCdata","onDoctype","ignoreDoctype","onError","note","userOptions","helper","validateOptions","onopentag","ontext","oncomment","onclosetag","oncdata","ondoctype","onprocessinginstruction","xml2js","addEventListener","removeEventListener","title","date","toLocaleString","description","link","keywords","selectedSource","articles","feeds","Tagesschau","SWR Aktuell","SWR Aktuell BW","SWR Aktuell RP","getFeed","resp","fetch","rss","channel","every","keyword","_text","includes","Date","pubDate","sort","getTime","source"],"mappings":"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"}